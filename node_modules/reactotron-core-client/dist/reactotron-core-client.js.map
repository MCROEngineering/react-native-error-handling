{"version":3,"file":"reactotron-core-client.js","sources":["../src/validate.ts","../src/plugins/logger.ts","../src/plugins/image.ts","../src/plugins/benchmark.ts","../src/plugins/state-responses.ts","../src/plugins/api-response.ts","../src/plugins/clear.ts","../src/serialize.ts","../src/stopwatch.ts","../src/reactotron-core-client.ts"],"sourcesContent":["import * as WebSocket from \"ws\"\nimport { ClientOptions } from \"./client-options\"\n\nconst isCreateSocketValid = (createSocket: (path: string) => WebSocket) => typeof createSocket !== \"undefined\" && createSocket !== null\nconst isHostValid = (host: string): boolean => typeof host === \"string\" && host && host !== \"\"\nconst isPortValid = (port: number): boolean => typeof port === \"number\" && port >= 1 && port <= 65535\nconst onCommandValid = (fn: (cmd: string) => any) => typeof fn === \"function\"\n\n/**\n * Ensures the options are sane to run this baby.  Throw if not.  These\n * are basically sanity checks.\n */\nconst validate = (options: ClientOptions) => {\n  const { createSocket, host, port, onCommand } = options\n\n  if (!isCreateSocketValid(createSocket)) {\n    throw new Error(\"invalid createSocket function\")\n  }\n\n  if (!isHostValid(host)) {\n    throw new Error(\"invalid host\")\n  }\n\n  if (!isPortValid(port)) {\n    throw new Error(\"invalid port\")\n  }\n\n  if (!onCommandValid(onCommand)) {\n    throw new Error(\"invalid onCommand handler\")\n  }\n}\n\nexport default validate\n","/**\n * Provides 4 features for logging.  log & debug are the same.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      log: (...args) => {\n        const content = (args && args.length === 1) ? args[0] : args\n        reactotron.send(\"log\", { level: \"debug\", message: content }, false)\n      },\n      logImportant: (...args) => {\n        const content = (args && args.length === 1) ? args[0] : args\n        reactotron.send(\"log\", { level: \"debug\", message: content }, true)\n      },\n      debug: (message, important = false) =>\n        reactotron.send(\"log\", { level: \"debug\", message }, !!important),\n      warn: message => reactotron.send(\"log\", { level: \"warn\", message }, true),\n      error: (message, stack) => reactotron.send(\"log\", { level: \"error\", message, stack }, true),\n    },\n  }\n}\n","/**\n * Provides an image.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      // expanded just to show the specs\n      image: ({ uri, preview, filename, width, height, caption }) =>\n        reactotron.send(\"image\", { uri, preview, filename, width, height, caption }),\n    },\n  }\n}\n","/**\n * Runs small high-unscientific benchmarks for you.\n */\nexport default () => reactotron => {\n  const { startTimer } = reactotron\n\n  const benchmark = title => {\n    const steps = []\n    const elapsed = startTimer()\n    const step = stepTitle => {\n      const previousTime = steps.length === 0 ? 0 : (steps[steps.length - 1] as any).time\n      const nextTime = elapsed()\n      steps.push({ title: stepTitle, time: nextTime, delta: nextTime - previousTime })\n    }\n    steps.push({ title, time: 0, delta: 0 })\n    const stop = stopTitle => {\n      step(stopTitle)\n      reactotron.send(\"benchmark.report\", { title, steps })\n    }\n    return { step, stop, last: stop }\n  }\n\n  return {\n    features: { benchmark },\n  }\n}\n","/**\n * Provides helper functions for send state responses.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      stateActionComplete: (name, action, important = false) =>\n        reactotron.send(\"state.action.complete\", { name, action }, !!important),\n\n      stateValuesResponse: (path, value, valid = true) =>\n        reactotron.send(\"state.values.response\", { path, value, valid }),\n\n      stateKeysResponse: (path, keys, valid = true) =>\n        reactotron.send(\"state.keys.response\", { path, keys, valid }),\n\n      stateValuesChange: changes => reactotron.send(\"state.values.change\", { changes }),\n\n      // sends the state backup over to the server\n      stateBackupResponse: state => reactotron.send(\"state.backup.response\", { state }),\n    },\n  }\n}\n","\n/**\n * Sends API request/response information.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      apiResponse: (request, response, duration) => {\n        const ok =\n          response &&\n          response.status &&\n          typeof response.status === \"number\" &&\n          response.status >= 200 &&\n          response.status <= 299\n        const important = !ok\n        reactotron.send(\"api.response\", { request, response, duration }, important)\n      },\n    },\n  }\n}\n","/**\n * Clears the reactotron server.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      clear: () => reactotron.send(\"clear\"),\n    },\n  }\n}\n","// JSON.stringify() doesn't support circular dependencies or keeping\n// falsy values.  This does.\n//\n// Mostly adapted from https://github.com/isaacs/json-stringify-safe\n\n// replacement tokens\nconst UNDEFINED = \"~~~ undefined ~~~\"\nconst NULL = `~~~ null ~~~`\nconst FALSE = `~~~ false ~~~`\nconst ZERO = `~~~ zero ~~~`\nconst EMPTY_STRING = `~~~ empty string ~~~`\nconst CIRCULAR = \"~~~ Circular Reference ~~~\"\nconst ANONYMOUS = \"~~~ anonymous function ~~~\"\nconst INFINITY = \"~~~ Infinity ~~~\"\nconst NEGATIVE_INFINITY = \"~~~ -Infinity ~~~\"\n// const NAN = '~~~ NaN ~~~'\n\n/**\n * Attempts to give a name to a function.\n *\n * @param {Function} fn - The function to name.\n */\nfunction getFunctionName(fn: any): string {\n  const n = fn.name\n  if (n === null || n === undefined || n === \"\") {\n    return ANONYMOUS\n  } else {\n    return `~~~ ${n}() ~~~`\n  }\n}\n\n/**\n * Serializes an object to JSON.\n *\n *  @param {any} source - The victim.\n */\nfunction serialize(source, proxyHack = false) {\n  const stack = []\n  const keys = []\n\n  /**\n   * Replace this object node with something potentially custom.\n   *\n   * @param {*} key - The key currently visited.\n   * @param {*} value - The value to replace.\n   */\n  function serializer(replacer) {\n    return function(this: any, key, value) {\n      // slam dunks\n      if (value === true) return true\n\n      // weird stuff\n      // if (Object.is(value, NaN)) return NAN // OK, apparently this is hard... leaving out for now\n      if (value === Infinity) return INFINITY\n      if (value === -Infinity) return NEGATIVE_INFINITY\n      if (value === 0) return ZERO\n\n      // classic javascript\n      if (value === undefined) return UNDEFINED\n      if (value === null) return NULL\n      if (value === false) return FALSE\n\n      // head shakers\n      if (value === -0) return ZERO // eslint-disable-line\n      if (value === \"\") return EMPTY_STRING\n\n      if (proxyHack && typeof value === \"object\" && value.nativeEvent) {\n        return value.nativeEvent\n      }\n\n      // known types that have easy resolving\n      switch (typeof value) {\n        case \"string\":\n          return value\n        case \"number\":\n          return value\n        case \"function\":\n          return getFunctionName(value)\n      }\n\n      if (stack.length > 0) {\n        // check for prior existance\n        const thisPos = stack.indexOf(this)\n        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n        if (~stack.indexOf(value)) value = CIRCULAR\n      } else {\n        stack.push(value)\n      }\n\n      return replacer == null ? value : replacer.call(this, key, value)\n    }\n  }\n\n  return JSON.stringify(source, serializer(null))\n}\n\nexport default serialize\n","/// <reference types=\"node\" />\n\ndeclare var global: any\n\nconst hasHirezNodeTimer =\n  false &&\n  typeof process === \"object\" &&\n  process &&\n  process.hrtime &&\n  typeof process.hrtime === \"function\"\n\n// the default timer\nconst defaultPerformanceNow = (started?: number) => Date.now()\n\n// try to find the browser-based performance timer\nconst nativePerformance =\n  typeof window !== \"undefined\" &&\n  window &&\n  (window.performance || (window as any).msPerformance || (window as any).webkitPerformance)\n\n// the function we're trying to assign\nlet performanceNow = defaultPerformanceNow\n\n// accepts an already started time and returns the number of milliseconds\nlet delta = (started: number) => performanceNow() - started\n\nif (hasHirezNodeTimer) {\n  performanceNow = process.hrtime as any\n  delta = started => performanceNow(started)[1] / 1000000\n} else if (global.nativePerformanceNow) {\n  // react native 47\n  performanceNow = global.nativePerformanceNow\n} else if (nativePerformance) {\n  // browsers + safely check for react native < 47\n  performanceNow = () => nativePerformance.now && nativePerformance.now()\n}\n\n/**\n * Starts a lame, low-res timer.  Returns a function which when invoked,\n * gives you the number of milliseconds since passing.  ish.\n */\nexport const start = () => {\n  //  record the start time\n  const started = performanceNow()\n  return () => delta(started)\n}\n","import * as WebSocket from \"ws\"\nimport validate from \"./validate\"\nimport logger from \"./plugins/logger\"\nimport image from \"./plugins/image\"\nimport benchmark from \"./plugins/benchmark\"\nimport stateResponses from \"./plugins/state-responses\"\nimport apiResponse from \"./plugins/api-response\"\nimport clear from \"./plugins/clear\"\nimport serialize from \"./serialize\"\nimport { start } from \"./stopwatch\"\nimport { ClientOptions } from \"./client-options\"\n\nexport const corePlugins = [\n  image(),\n  logger(),\n  benchmark(),\n  stateResponses(),\n  apiResponse(),\n  clear(),\n]\n\nconst DEFAULT_OPTIONS: ClientOptions = {\n  createSocket: null,\n  host: \"localhost\",\n  port: 9090,\n  name: \"reactotron-core-client\",\n  secure: false,\n  plugins: corePlugins,\n  safeRecursion: true,\n  onCommand: command => null,\n  onConnect: () => null,\n  onDisconnect: () => null,\n}\n\n// these are not for you.\nconst reservedFeatures = [\n  \"options\",\n  \"connected\",\n  \"socket\",\n  \"plugins\",\n  \"configure\",\n  \"connect\",\n  \"send\",\n  \"use\",\n  \"startTimer\",\n]\nconst isReservedFeature = (value: string) => reservedFeatures.some(res => res === value)\n\nfunction emptyPromise() {\n  return Promise.resolve(\"\")\n}\n\nexport interface CustomCommand {\n  id: number\n  command: string\n  handler: () => void\n}\n\nexport class Client {\n  // the configuration options\n  options: ClientOptions = Object.assign({}, DEFAULT_OPTIONS)\n\n  /**\n   * Are we connected to a server?\n   */\n  connected = false\n\n  /**\n   * The socket we're using.\n   */\n  socket: WebSocket = null\n\n  /**\n   * Available plugins.\n   */\n  plugins: any[] = []\n\n  /**\n   * Messages that need to be sent.\n   */\n  sendQueue: any[] = []\n\n  /**\n   * Are we ready to start communicating?\n   */\n  isReady = false\n\n  /**\n   * The last time we sent a message.\n   */\n  lastMessageDate = new Date()\n\n  /**\n   * The registered custom commands\n   */\n  customCommands: CustomCommand[] = []\n\n  /**\n   * The current ID for custom commands\n   */\n  customCommandLatestId: number = 1\n\n  /**\n   * Starts a timer and returns a function you can call to stop it and return the elapsed time.\n   */\n  startTimer = () => start()\n\n  /**\n   * Set the configuration options.\n   */\n  configure(options: ClientOptions = {}): Client {\n    // options get merged & validated before getting set\n    const newOptions = Object.assign({}, this.options, options)\n    validate(newOptions)\n    this.options = newOptions\n\n    // if we have plugins, let's add them here\n    if (Array.isArray(this.options.plugins)) {\n      this.options.plugins.forEach(p => this.use(p))\n    }\n\n    return this\n  }\n\n  close() {\n    this.connected = false\n    this.socket && this.socket.close && this.socket.close()\n  }\n\n  /**\n   * Connect to the Reactotron server.\n   */\n  connect(): Client {\n    this.connected = true\n    const {\n      createSocket,\n      secure,\n      host,\n      environment,\n      port,\n      name,\n      client = {},\n      getClientId,\n    } = this.options\n    const { onCommand, onConnect, onDisconnect } = this.options\n\n    // establish a connection to the server\n    const protocol = secure ? \"wss\" : \"ws\"\n    const socket = createSocket(`${protocol}://${host}:${port}`)\n\n    // fires when we talk to the server\n    const onOpen = () => {\n      // fire our optional onConnect handler\n      onConnect && onConnect()\n\n      // trigger our plugins onConnect\n      this.plugins.forEach(p => p.onConnect && p.onConnect())\n\n      const getClientIdPromise = getClientId ? getClientId : emptyPromise\n\n      getClientIdPromise().then(clientId => {\n        this.isReady = true\n        // introduce ourselves\n        this.send(\"client.intro\", {\n          environment,\n          ...client,\n          name,\n          clientId,\n          \"reactotronCoreClientVersion\": \"REACTOTRON_CORE_CLIENT_VERSION\",\n        })\n\n        // flush the send queue\n        while (this.sendQueue.length > 0) {\n          const h = this.sendQueue[0]\n          this.sendQueue = this.sendQueue.slice(1)\n          this.socket.send(h)\n        }\n      })\n    }\n\n    // fires when we disconnect\n    const onClose = () => {\n      this.isReady = false\n      // trigger our disconnect handler\n      onDisconnect && onDisconnect()\n\n      // as well as the plugin's onDisconnect\n      this.plugins.forEach(p => p.onDisconnect && p.onDisconnect())\n    }\n\n    // fires when we receive a command, just forward it off\n    const onMessage = (data: any) => {\n      const command = JSON.parse(data)\n      // trigger our own command handler\n      onCommand && onCommand(command)\n\n      // trigger our plugins onCommand\n      this.plugins.forEach(p => p.onCommand && p.onCommand(command))\n\n      // trigger our registered custom commands\n      if (command.type === \"custom\") {\n        this.customCommands.filter(cc => cc.command === command.payload).forEach(cc => cc.handler())\n      } else if (command.type === \"setClientId\") {\n        this.options.setClientId && this.options.setClientId(command.payload)\n      }\n    }\n\n    // this is ws style from require('ws') on node js\n    if (socket.on) {\n      socket.on(\"open\", onOpen)\n      socket.on(\"close\", onClose)\n      socket.on(\"message\", onMessage)\n    } else {\n      // this is a browser\n      socket.onopen = onOpen\n      socket.onclose = onClose\n      socket.onmessage = evt => onMessage(evt.data)\n    }\n\n    // assign the socket to the instance\n    this.socket = socket\n\n    return this\n  }\n\n  /**\n   * Sends a command to the server\n   */\n  send = (type, payload = {}, important = false) => {\n    // jet if we don't have a socket\n    if (!this.socket) {\n      return\n    }\n\n    // set the timing info\n    const date = new Date()\n    let deltaTime = date.getTime() - this.lastMessageDate.getTime()\n    // glitches in the matrix\n    if (deltaTime < 0) {\n      deltaTime = 0\n    }\n    this.lastMessageDate = date\n\n    const fullMessage = {\n      type,\n      payload,\n      important: !!important,\n      date: date.toISOString(),\n      deltaTime,\n    }\n\n    const serializedMessage = serialize(fullMessage, this.options.proxyHack)\n\n    if (this.isReady) {\n      // send this command\n      this.socket.send(serializedMessage)\n    } else {\n      // queue it up until we can connect\n      this.sendQueue.push(serializedMessage)\n    }\n  }\n\n  /**\n   * Sends a custom command to the server to displays nicely.\n   */\n  display(config: any = {}) {\n    const { name, value, preview, image: img, important = false } = config\n    const payload = {\n      name,\n      value: value || null,\n      preview: preview || null,\n      image: img || null,\n    }\n    this.send(\"display\", payload, important)\n  }\n\n  /**\n   * Client libraries can hijack this to report errors.\n   */\n  reportError(this: any, error) {\n    this.error(error)\n  }\n\n  /**\n   * Adds a plugin to the system\n   */\n  use(pluginCreator?: (client: Client) => any): Client {\n    // we're supposed to be given a function\n    if (typeof pluginCreator !== \"function\") {\n      throw new Error(\"plugins must be a function\")\n    }\n\n    // execute it immediately passing the send function\n    const plugin = pluginCreator.bind(this)(this)\n\n    // ensure we get an Object-like creature back\n    if (typeof plugin !== \"object\") {\n      throw new Error(\"plugins must return an object\")\n    }\n\n    // do we have features to mixin?\n    if (plugin.features) {\n      // validate\n      if (typeof plugin.features !== \"object\") {\n        throw new Error(\"features must be an object\")\n      }\n\n      // here's how we're going to inject these in\n      const inject = (key: string) => {\n        // grab the function\n        const featureFunction = plugin.features[key]\n\n        // only functions may pass\n        if (typeof featureFunction !== \"function\") {\n          throw new Error(`feature ${key} is not a function`)\n        }\n\n        // ditch reserved names\n        if (isReservedFeature(key)) {\n          throw new Error(`feature ${key} is a reserved name`)\n        }\n\n        // ok, let's glue it up... and lose all respect from elite JS champions.\n        this[key] = featureFunction\n      }\n\n      // let's inject\n      Object.keys(plugin.features).forEach(key => inject(key))\n    }\n\n    // add it to the list\n    this.plugins.push(plugin)\n\n    // call the plugins onPlugin\n    plugin.onPlugin && typeof plugin.onPlugin === \"function\" && plugin.onPlugin.bind(this)(this)\n\n    // chain-friendly\n    return this\n  }\n\n  onCustomCommand(command: string, handler: () => void): () => void {\n    // Create this command handlers object\n    const customHandler: CustomCommand = {\n      id: this.customCommandLatestId,\n      command,\n      handler,\n    }\n\n    // Increment our id counter\n    this.customCommandLatestId += 1\n\n    // Add it to our array\n    this.customCommands.push(customHandler)\n\n    this.send(\"customCommand.register\", { id: customHandler.id, command: customHandler.command })\n\n    return () => {\n      this.customCommands = this.customCommands.filter(cc => cc.id !== customHandler.id)\n\n      this.send(\"customCommand.unregister\", {\n        id: customHandler.id,\n        command: customHandler.command,\n      })\n    }\n  }\n}\n\n// convenience factory function\nexport function createClient (options?: ClientOptions) {\n  const client = new Client()\n  client.configure(options)\n  return client\n}\n"],"names":["isCreateSocketValid","createSocket","isHostValid","host","isPortValid","port","onCommandValid","fn","validate","options","onCommand","Error","reactotron","features","log","_i","args","content","length","send","level","message","logImportant","debug","important","warn","error","stack","image","_a","uri","preview","filename","width","height","caption","startTimer","benchmark","title","steps","elapsed","step","stepTitle","previousTime","time","nextTime","push","delta","stop","stopTitle","last","stateActionComplete","name","action","stateValuesResponse","path","value","valid","stateKeysResponse","keys","stateValuesChange","changes","stateBackupResponse","state","apiResponse","request","response","duration","status","clear","UNDEFINED","NULL","FALSE","ZERO","EMPTY_STRING","CIRCULAR","ANONYMOUS","INFINITY","NEGATIVE_INFINITY","getFunctionName","n","serialize","source","proxyHack","replacer","JSON","stringify","key","Infinity","undefined","nativeEvent","thisPos","indexOf","this","splice","call","defaultPerformanceNow","started","Date","now","nativePerformance","window","performance","msPerformance","webkitPerformance","performanceNow","global","nativePerformanceNow","start","corePlugins","logger","stateResponses","DEFAULT_OPTIONS","secure","plugins","safeRecursion","command","onConnect","onDisconnect","reservedFeatures","isReservedFeature","some","res","emptyPromise","Promise","resolve","Object","assign","type","payload","_this","socket","date","deltaTime","getTime","lastMessageDate","serializedMessage","toISOString","isReady","sendQueue","Client","newOptions","Array","isArray","forEach","p","use","connected","close","environment","_b","client","getClientId","_c","onOpen","then","clientId","reactotronCoreClientVersion","h","slice","onClose","onMessage","data","parse","customCommands","filter","cc","handler","setClientId","on","onopen","onclose","onmessage","evt","config","img","pluginCreator","plugin","bind","featureFunction","inject_1","onPlugin","customHandler","id","customCommandLatestId","createClient","configure"],"mappings":"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"}